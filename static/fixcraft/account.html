<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>FixCraft Identity Center</title>
		<link rel="stylesheet" href="styles.css" />
		<script src="../build-flags.js"></script>
	</head>
	<body>
		<div class="fc-backdrop" aria-hidden="true"></div>
		<main class="account-shell" data-view="loading">
			<header class="account-hero">
				<div class="hero-meta">
					<div class="avatar" data-avatar aria-label="Account avatar">FC</div>
					<div>
						<p class="status-chip status-chip--warn" data-status-chip>
							Checking FixCraft status…
						</p>
						<h1 data-hero-name>FixCraft Identity</h1>
						<p class="hero-email" data-hero-email>
							Manage your FixCraft account on this device.
						</p>
						<div class="hero-plan" data-plan-badge data-tier="free">
							Plan unknown
						</div>
					</div>
				</div>
				<div class="hero-actions">
					<button class="btn outline" data-action="open-auth" data-when="unlinked">
						Link FixCraft ID
					</button>
					<button class="btn ghost" data-action="refresh" data-when="linked">
						Sync status
					</button>
					<button class="btn danger" data-action="unlink" data-when="linked">
						Sign out
					</button>
				</div>
			</header>
			<p class="link-hint" data-link-hint>
				We’ll show your workspace once you’re signed in.
			</p>
			<section class="alert-banner" data-alert></section>

			<section class="quick-stats">
				<article>
					<h4>Plan</h4>
					<p data-stat-plan>—</p>
				</article>
				<article>
					<h4>Environment</h4>
					<p data-stat-platform>Detecting…</p>
				</article>
				<article>
					<h4>Location</h4>
					<p data-stat-location>—</p>
				</article>
				<article>
					<h4>Timezone</h4>
					<p data-stat-timezone>—</p>
				</article>
				<article>
					<h4>Last sync</h4>
					<p data-stat-sync>Never</p>
				</article>
			</section>

			<section class="grid">
				<article class="card security-card">
					<header>
						<div>
							<p class="eyebrow">Security</p>
							<h2>Protection controls</h2>
						</div>
						<button class="btn ghost small" data-action="change-password">
							Change password
						</button>
					</header>
					<div class="switch-row">
						<div>
							<strong>Two-factor authentication</strong>
							<p>
								Add an extra verification step for every sign-in attempt.
							</p>
						</div>
						<label class="fc-switch">
							<input type="checkbox" data-pref="twoFactorEnabled" />
							<span></span>
						</label>
					</div>
					<div class="switch-row">
						<div>
							<strong>Login alerts</strong>
							<p>Receive alerts whenever a new device is registered.</p>
						</div>
						<label class="fc-switch">
							<input type="checkbox" data-pref="loginAlerts" />
							<span></span>
						</label>
					</div>
					<div class="token-box">
						<div>
							<strong>Bearer token</strong>
							<p class="token-hint" data-token-hint>Hidden for safety.</p>
						</div>
						<div class="token-actions">
							<button class="btn ghost small" data-action="copy-token">Copy</button>
							<button class="btn ghost small" data-action="show-token">Reveal</button>
						</div>
					</div>
				</article>

				<article class="card sessions-card">
					<header>
						<div>
							<p class="eyebrow">Sessions</p>
							<h2>Active devices</h2>
						</div>
						<button class="btn ghost small" data-action="refresh">
							Refresh
						</button>
					</header>
					<ul class="session-list" data-session-list>
						<li class="session-empty">
							Link your account to see enrolled devices.
						</li>
					</ul>
				</article>

				<article class="card profile-card">
					<header>
						<div>
							<p class="eyebrow">Profile</p>
							<h2>Contact preferences</h2>
						</div>
					</header>
					<form data-form="profile">
						<label>
							Full name
							<input name="fullName" type="text" autocomplete="name" />
						</label>
						<label>
							Primary email
							<input name="email" type="email" autocomplete="email" />
						</label>
						<label>
							Backup email
							<input name="backupEmail" type="email" autocomplete="email" />
						</label>
						<label>
							Location
							<input name="location" type="text" placeholder="City, region" />
						</label>
						<label>
							Timezone
							<input name="timezone" type="text" placeholder="UTC" />
						</label>
						<div class="form-row">
							<label>
								Avatar URL
								<input
									name="avatarUrl"
									type="url"
									placeholder="https://cdn.fixcraft.jp/avatar.jpg"
								/>
							</label>
							<button
								class="btn outline small"
								type="button"
								data-action="save-avatar"
							>
								Update avatar
							</button>
						</div>
						<div class="form-actions">
							<button class="btn primary" type="submit">Save changes</button>
							<button
								class="btn ghost"
								type="button"
								data-action="reset-profile"
							>
								Reset
							</button>
						</div>
					</form>
					<div class="upload-row">
						<label class="upload">
							<input type="file" accept="image/*" data-avatar-file />
							<span>Upload avatar image</span>
						</label>
					</div>
				</article>

				<article class="card perks-card">
					<header>
						<div>
							<p class="eyebrow">Perks</p>
							<h2>Included with your plan</h2>
						</div>
					</header>
					<ul class="perks-grid" data-perk-list>
						<li>Link your FixCraft ID to surface workspace perks.</li>
					</ul>
					<div class="perk-actions">
						<button class="btn primary" data-action="open-portal">
							Manage subscription
						</button>
						<button class="btn outline" data-action="support">
							Contact support
						</button>
					</div>
				</article>
			</section>
		</main>

		<aside class="auth-panel" data-auth-panel hidden>
			<form class="auth-card" data-form="signin">
				<button
					type="button"
					class="close"
					data-action="close-auth"
					aria-label="Close sign-in dialog"
				>
					×
				</button>
				<p class="eyebrow">FixCraft ID</p>
				<h2>Sign in to continue</h2>
				<p class="auth-intro">
					Use your FixCraft username or email along with your password to link
					this session.
				</p>
				<label>
					Email or username
					<input name="username" type="text" autocomplete="username" required />
				</label>
				<label>
					Password
					<input
						name="password"
						type="password"
						autocomplete="current-password"
						required
					/>
				</label>
				<button class="btn primary" type="submit">Sign in</button>
				<p class="auth-hint" data-auth-message>
					Need help? security@fixcraft.jp
				</p>
			</form>
		</aside>

		<template id="session-row">
			<li class="session-row">
				<div>
					<strong data-row-title></strong>
					<p data-row-meta></p>
				</div>
				<button class="btn ghost small" data-row-action>Revoke</button>
			</li>
		</template>

		<script>
			(() => {
				const buildFlags =
					window.top?.AboutBrowserBuildFlags ||
					window.AboutBrowserBuildFlags ||
					{};

				if (buildFlags.disableAccountPortal) {
					document.body.innerHTML = `
            <main class="account-shell account-shell--disabled">
              <h1>Account controls unavailable</h1>
              <p>This static build cannot reach the FixCraft identity service. Deploy the official IridiumOS stack to manage identities.</p>
            </main>
          `;
					return;
				}

				const portalUrl =
					buildFlags.fixcraftPortal || "https://fixcraft.org/account";
				const webLoginUrl =
					buildFlags.fixcraftLogin ||
					(portalUrl.includes("/account")
						? portalUrl.replace(/\/account\/?$/, "/login")
						: `${portalUrl.replace(/\/$/, "")}/login`);
				const supportMail =
					buildFlags.fixcraftSupport || "security@fixcraft.jp";
				const defaultApi =
					buildFlags.fixcraftApiBase ||
					(window.location.hostname === "localhost"
						? "http://localhost:3221"
						: "https://api.fixcraft.jp");
				const API_BASE = defaultApi.replace(/\/$/, "");
				const ACCOUNT_LINK_ENDPOINT = "/fixcraft/account-link";
				const desktop = window.top?.iridium || window.top?.anura;
				if (!window.chrome) {
					window.chrome = {};
				}

				const root = document.querySelector(".account-shell");
				const avatarEl = document.querySelector("[data-avatar]");
				const heroName = document.querySelector("[data-hero-name]");
				const heroEmail = document.querySelector("[data-hero-email]");
				const planBadge = document.querySelector("[data-plan-badge]");
				const statusChip = document.querySelector("[data-status-chip]");
				const linkHint = document.querySelector("[data-link-hint]");
				const alertBanner = document.querySelector("[data-alert]");
				const perkList = document.querySelector("[data-perk-list]");
				const sessionList = document.querySelector("[data-session-list]");
				const sessionTemplate = document.getElementById("session-row");
				const profileForm = document.querySelector('[data-form="profile"]');
				const loginForm = document.querySelector('[data-form="signin"]');
				const authPanel = document.querySelector("[data-auth-panel]");
				const authMessage = document.querySelector("[data-auth-message]");
				const toggles = Array.from(document.querySelectorAll("[data-pref]"));
				const tokenHint = document.querySelector("[data-token-hint]");
				const avatarFileInput = document.querySelector("[data-avatar-file]");
				const signOutButton = document.querySelector('[data-action="unlink"]');
				const stats = {
					plan: document.querySelector("[data-stat-plan]"),
					location: document.querySelector("[data-stat-location]"),
					timezone: document.querySelector("[data-stat-timezone]"),
					sync: document.querySelector("[data-stat-sync]"),
					platform: document.querySelector("[data-stat-platform]"),
				};

				const PLAN_PERKS = {
					free: [
						{
							title: "Local Iridium workspace",
							body: "Customize wallpapers, layouts, and offline apps.",
						},
						{
							title: "Manual downloads",
							body: "Fetch open-source builds from public mirrors.",
						},
						{
							title: "Device sandbox",
							body: "Keep FixCraft data scoped to this browser profile.",
						},
					],
					premium: [
						{
							title: "FixCraft VPN mesh",
							body: "Private WireGuard profiles delivered via FixCraft One.",
						},
						{
							title: "Priority modules",
							body: "Unlock premium x86 images & rapid updates.",
						},
						{
							title: "Linked notifications",
							body: "Receive device alerts and runbooks across fleets.",
						},
					],
					admin: [
						{
							title: "Global policy sync",
							body: "Push compliance baselines and cert pinning at scale.",
						},
						{
							title: "Runbook automation",
							body: "Dispatch scripts, revoke devices, and stage rollbacks.",
						},
						{
							title: "24/7 FixCraft support",
							body: "Direct line to core engineers with elevated SLAs.",
						},
					],
				};

				const SESSION_STORAGE_KEY = "fixcraft-session-id";
				const SESSION_HEARTBEAT_INTERVAL_MS = 60 * 1000;

				const state = {
					account: readAccount(),
					profile: null,
					sessions: [],
					environment: describeEnvironment(),
					loading: false,
					sessionId: readStoredSessionId(),
				};

				let revealTimer = null;
				let avatarObjectUrl = null;
				let avatarLoadId = 0;
				let sessionHeartbeatTimer = null;
				let signOutArmed = false;
				let signOutConfirmTimer = null;
				document.body.dataset.accountLinked = state.account ? "true" : "false";
				document.body.dataset.desktop = desktop ? "true" : "false";
				disableServiceWorkers();
				stats.platform.textContent = state.environment;
				updateLinkHint();
				syncAccountView();
				if (state.account?.avatarUrl) {
					updateAvatar(
						state.account.avatarUrl,
						state.account.displayName || state.account.email || state.account.username,
					);
				}
				bootstrapFromServer();

				window.addEventListener("fixcraft-account:linked", (event) => {
					const payload = event?.detail;
					if (!payload?.token) return;
					persistAccount(
						{
							token: payload.token,
							email: payload.email,
							username: payload.username,
							displayName: payload.displayName,
							plan: payload.plan,
							avatarUrl: payload.avatarUrl || null,
							lastSync: payload.updatedAt || Date.now(),
						},
						{ silent: true },
					);
					if (!state.profile) {
						fetchProfile();
					}
				});

				if (state.account?.token) {
					fetchProfile();
					scheduleSessionHeartbeat();
				} else {
					root.dataset.view = "empty";
				}

				document.body.addEventListener("click", handleActionClick);
				sessionList?.addEventListener("click", handleSessionClick);
				loginForm?.addEventListener("submit", handleLoginSubmit);
				profileForm?.addEventListener("submit", handleProfileSubmit);
				toggles.forEach((input) =>
					input.addEventListener("change", handlePrefToggle),
				);
				avatarFileInput?.addEventListener("change", handleAvatarUpload);
				window.addEventListener("focus", () => sendSessionHeartbeat());

				function readAccount() {
					const fromSettings = safeReadSetting();
					if (fromSettings) {
						return { ...fromSettings };
					}
					try {
						const raw = localStorage.getItem("fixcraft-account");
						return raw ? JSON.parse(raw) : null;
					} catch {
						return null;
					}
				}

				function safeReadSetting() {
					try {
						const raw =
							desktop?.settings?.get?.("fixcraft-account") ?? null;
						if (!raw) return null;
						if (typeof raw === "string") {
							return JSON.parse(raw);
						}
						return raw;
					} catch {
						return null;
					}
				}

				function safePersistSetting(value) {
					try {
						const result = desktop?.settings?.set?.(
							"fixcraft-account",
							value,
						);
						if (result?.then) {
							result.catch(() => {});
						}
					} catch {
						// noop
					}
				}

				function readStoredSessionId() {
					try {
						return localStorage.getItem(SESSION_STORAGE_KEY) || null;
					} catch {
						return null;
					}
				}

				function persistSessionId(value) {
					state.sessionId = value;
					try {
						if (value) {
							localStorage.setItem(SESSION_STORAGE_KEY, value);
						} else {
							localStorage.removeItem(SESSION_STORAGE_KEY);
						}
					} catch {
						// ignore
					}
				}

				function ensureSessionId() {
					if (state.sessionId) {
						return state.sessionId;
					}
					const generated = generateSessionId();
					persistSessionId(generated);
					return generated;
				}

				function generateSessionId() {
					if (typeof crypto !== "undefined" && crypto.randomUUID) {
						return crypto.randomUUID();
					}
					return `fc-${Math.random().toString(36).slice(2, 10)}${Date.now().toString(36)}`;
				}

				function persistAccount(value, opts = {}) {
					if (!value) {
						try {
							localStorage.removeItem("fixcraft-account");
						} catch {
							// noop
						}
						safePersistSetting(null);
						state.account = null;
						state.profile = null;
						state.sessions = [];
						document.body.dataset.accountLinked = "false";
						updateLinkHint();
						syncAccountView();
						updateAvatar(null);
						persistSessionId(null);
						stopSessionHeartbeat();
						if (!opts.silent) {
							showAlert("Signed out of FixCraft.", "success");
						}
						return;
					}
					const previousAccount = state.account;
					const payload = {
						token: value.token,
						email: value.email || value.user?.email || null,
						username: value.username || value.user?.username || null,
						displayName:
							value.displayName ||
							value.fullName ||
							value.user?.displayName ||
							value.user?.username ||
							null,
						plan: value.plan || value.user?.tier || null,
						lastSync: value.lastSync || Date.now(),
						avatarUrl:
							value.avatarUrl ||
							value.user?.avatarUrl ||
							value.user?.avatar ||
							previousAccount?.avatarUrl ||
							null,
					};
					safePersistSetting(payload);
					try {
						localStorage.setItem(
							"fixcraft-account",
							JSON.stringify(payload),
						);
					} catch {
						// noop
					}
					state.account = payload;
					document.body.dataset.accountLinked = "true";
					updateAvatar(
						payload.avatarUrl,
						payload.displayName || payload.email || payload.username,
					);
					updateLinkHint();
					syncAccountView();
					scheduleSessionHeartbeat();
					if (!opts.silent) {
						showAlert("Linked to FixCraft.", "success");
					}
				}

				function describeEnvironment() {
					if (!desktop) {
						return "Browser sandbox";
					}
					const version =
						desktop.version?.pretty || desktop.version?.codename || "";
					const platform =
						desktop.platform?.label ||
						desktop.platform?.type ||
						desktop.platform ||
						"Iridium";
					return [platform, version].filter(Boolean).join(" • ");
				}

				function scheduleSessionHeartbeat() {
					if (!state.account?.token) return;
					sendSessionHeartbeat();
					if (sessionHeartbeatTimer) {
						clearInterval(sessionHeartbeatTimer);
					}
					sessionHeartbeatTimer = setInterval(() => {
						sendSessionHeartbeat();
					}, SESSION_HEARTBEAT_INTERVAL_MS);
				}

				function stopSessionHeartbeat() {
					if (sessionHeartbeatTimer) {
						clearInterval(sessionHeartbeatTimer);
						sessionHeartbeatTimer = null;
					}
				}

				function sendSessionHeartbeat(extra = {}) {
					if (!state.account?.token) return;
					const sessionId = ensureSessionId();
					const tz =
						Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC";
					const payload = {
						sessionId,
						title: state.environment,
						platform:
							navigator.userAgentData?.platform ||
							navigator.platform ||
							"unknown",
						location: state.profile?.location || null,
						timezone: tz,
						lastSeen: "Just now",
						...extra,
					};
					apiRequest("/api/sessions/heartbeat", {
						method: "POST",
						body: payload,
					})
						.then((response) => {
							if (response?.sessionId && response.sessionId !== state.sessionId) {
								persistSessionId(response.sessionId);
							}
						})
						.catch(() => {});
				}

				async function bootstrapFromServer() {
					const payload = await fetchServerLink();
					if (!payload?.linked || !payload.token) {
						if (!state.account) {
							syncAccountView();
						}
						return;
					}
					const shouldPersist =
						!state.account ||
						state.account.token !== payload.token ||
						(payload.updatedAt &&
							payload.updatedAt > (state.account.lastSync || 0));
					if (shouldPersist) {
						persistAccount(
							{
								token: payload.token,
								email: payload.email || state.account?.email,
								username: payload.username || state.account?.username,
								displayName:
									payload.displayName ||
									state.account?.displayName ||
									payload.email ||
									payload.username,
								plan: payload.plan || state.account?.plan,
								avatarUrl:
									payload.avatarUrl ||
									state.account?.avatarUrl ||
									null,
								lastSync: payload.updatedAt || Date.now(),
							},
							{ silent: true },
						);
					}
					if (!state.profile && payload.linked) {
						fetchProfile();
					}
				}

				async function fetchServerLink() {
					try {
						const response = await fetch(ACCOUNT_LINK_ENDPOINT, {
							credentials: "include",
						});
						if (!response.ok) {
							return null;
						}
						const data = await response.json();
						return data;
					} catch {
						return null;
					}
				}

				function syncAccountView() {
					const linked = Boolean(state.account);
					const profileReady = Boolean(state.profile);
					if (!linked) {
						root.dataset.view = "empty";
						statusChip.textContent = "No account linked";
						statusChip.className = "status-chip status-chip--warn";
						heroName.textContent = "FixCraft Identity";
						heroEmail.textContent =
							"Link your FixCraft ID to sync premium resources.";
						planBadge.textContent = "Not linked";
						planBadge.dataset.tier = "free";
						perkList.innerHTML =
							"<li>Sign in to surface plan-specific benefits.</li>";
						sessionList.innerHTML =
							'<li class="session-empty">Link your account to see active sessions.</li>';
						stats.plan.textContent = "Unlinked";
					} else if (!profileReady) {
						root.dataset.view = "loading";
						statusChip.textContent = "Syncing FixCraft profile…";
						statusChip.className = "status-chip status-chip--sync";
					} else {
						root.dataset.view = "ready";
						statusChip.textContent = "FixCraft ID linked";
						statusChip.className = "status-chip status-chip--ready";
					}
					if (linked) {
						const name =
							state.profile?.fullName ||
							state.account?.displayName ||
							state.account?.email ||
							state.account?.username ||
							"FixCraft member";
						heroName.textContent = name;
						heroEmail.textContent =
							state.profile?.email ||
							state.account?.email ||
							"Linked to FixCraft workspace.";
						const planLabel =
							state.profile?.plan || state.account?.plan || "FixCraft Free";
						planBadge.textContent = planLabel;
						planBadge.dataset.tier = determineTier(planLabel, state.profile?.role);
						if (!profileReady) {
							stats.plan.textContent = planLabel;
						}
					}
					stats.sync.textContent = formatSyncTime(state.account?.lastSync);
				}

				function updateLinkHint() {
					if (!linkHint) return;
					if (!state.account) {
						linkHint.textContent =
							"Link your FixCraft ID to unlock VPN meshes, remote policies, and premium downloads.";
						return;
					}
					if (!desktop) {
						linkHint.textContent =
							"Running outside of Iridium — your token lives only in this browser.";
						return;
					}
					linkHint.textContent = `Signed in as ${
						state.account.displayName || state.account.email || "FixCraft user"
					}.`;
				}

				async function fetchProfile() {
					if (!state.account?.token) {
						return;
					}
					root.dataset.view = "loading";
					statusChip.textContent = "Syncing FixCraft profile…";
					statusChip.className = "status-chip status-chip--sync";
					try {
						const [profile, sessions] = await Promise.all([
							apiRequest("/api/user"),
							apiRequest("/api/sessions"),
						]);
						state.profile = profile;
						state.sessions = Array.isArray(sessions) ? sessions : [];
						persistAccount(
							{
								...state.account,
								email: profile.email,
								displayName: profile.fullName || profile.email,
								plan: profile.plan,
								avatarUrl: profile.avatarUrl || state.account?.avatarUrl || null,
								lastSync: Date.now(),
							},
							{ silent: true },
						);
						renderProfile();
						renderSessions();
						renderPerks();
						root.dataset.view = "ready";
						statusChip.textContent = "FixCraft ID linked";
						statusChip.className = "status-chip status-chip--ready";
						showAlert("Account synced.", "success", true);
					} catch (error) {
						handleApiError(error);
					}
				}

				async function apiFetch(pathOrUrl, options = {}) {
					if (!state.account?.token) {
						const error = new Error("missing_token");
						error.status = 401;
						throw error;
					}
					const url = buildApiUrl(pathOrUrl);
					const headers = {
						...(options.headers || {}),
					};
					if (!options.raw) {
						headers.Accept = headers.Accept || "application/json";
					}
					if (options.body && !headers["Content-Type"]) {
						headers["Content-Type"] = "application/json";
					}
					headers.Authorization = `Bearer ${state.account.token}`;
					const sessionId = ensureSessionId();
					if (sessionId) {
						headers["X-FC-Session-ID"] = sessionId;
					}
					const fetchOptions = {
						method: options.method || "GET",
						headers,
						credentials: "omit",
						cache: "no-store",
					};
					if (options.body) {
						fetchOptions.body =
							typeof options.body === "string"
								? options.body
								: JSON.stringify(options.body);
					}
					const response = await fetch(url, fetchOptions);
					if (!response.ok) {
						if (options.raw) {
							const err = new Error(`Request failed (${response.status})`);
							err.status = response.status;
							throw err;
						}
						let data = null;
						try {
							const text = await response.text();
							data = text ? JSON.parse(text) : null;
						} catch {
							data = null;
						}
						const message =
							data?.error ||
							data?.message ||
							`Request failed (${response.status})`;
						const err = new Error(message);
						err.status = response.status;
						throw err;
					}
					return response;
				}

				async function apiRequest(path, options = {}) {
					const response = await apiFetch(path, options);
					const text = await response.text();
					return text ? JSON.parse(text) : null;
				}

				function buildApiUrl(path) {
					if (!path) return API_BASE;
					if (path.startsWith("http")) return path;
					return `${API_BASE}${path.startsWith("/") ? "" : "/"}${path}`;
				}

				function renderProfile() {
					 if (!state.profile) return;
					const profile = state.profile;
					const plan = profile.plan || state.account?.plan || "FixCraft Free";
					const tier = determineTier(plan, profile.role);
					heroName.textContent =
						profile.fullName ||
						profile.displayName ||
						state.account?.displayName ||
						"FixCraft member";
					heroEmail.textContent =
						profile.email ||
						state.account?.email ||
						"Linked to FixCraft workspace.";
					planBadge.textContent = plan;
					planBadge.dataset.tier = tier;
					stats.plan.textContent = `${plan}${
						profile.role ? ` • ${profile.role}` : ""
					}`;
					stats.location.textContent =
						profile.location || "Add your location";
					stats.timezone.textContent =
						profile.timezone || "Set your timezone";
					stats.sync.textContent = formatSyncTime(state.account?.lastSync);
					updateTokenHint();
					updateAvatar(profile.avatarUrl, profile.fullName || profile.email);
					fillProfileForm();
					toggles.forEach((input) => {
						const pref = input.dataset.pref;
						if (typeof profile[pref] !== "undefined") {
							input.checked = Boolean(profile[pref]);
						}
					});
				}

				function fillProfileForm() {
					if (!profileForm || !state.profile) return;
					const profile = state.profile;
					const map = {
						fullName: profile.fullName || "",
						email: profile.email || "",
						backupEmail: profile.backupEmail || "",
						location: profile.location || "",
						timezone: profile.timezone || "",
						avatarUrl: profile.avatarUrl || "",
					};
					Object.entries(map).forEach(([key, value]) => {
						if (profileForm.elements[key]) {
							profileForm.elements[key].value = value || "";
						}
					});
				}

				function renderSessions() {
					if (!sessionList) return;
					sessionList.innerHTML = "";
					const list = Array.isArray(state.sessions) ? state.sessions : [];
					const currentSessionId = state.sessionId;
					if (!state.profile) {
						sessionList.innerHTML =
							'<li class="session-empty">Link your account to see active sessions.</li>';
						return;
					}
					if (list.length === 0) {
						sessionList.innerHTML =
							'<li class="session-empty">No tracked sessions yet.</li>';
						return;
					}
					list.forEach((session) => {
						const node =
							sessionTemplate.content.firstElementChild.cloneNode(true);
						const titleEl = node.querySelector("[data-row-title]");
						const metaEl = node.querySelector("[data-row-meta]");
						titleEl.textContent =
							session.title || session.platform || "Unnamed device";
						const isCurrent =
							session.current === true ||
							(currentSessionId && session.id === currentSessionId);
						const action = node.querySelector("[data-row-action]");
						const metaParts = [];
						if (session.platform) {
							metaParts.push(session.platform);
						}
						if (session.location) metaParts.push(session.location);
						if (session.lastSeen) metaParts.push(session.lastSeen);
						metaEl.textContent =
							metaParts.join(" • ") || session.ip || "Recently active";
						if (isCurrent) {
							action.textContent = "This device";
							action.disabled = true;
							action.classList.add("current-device");
							node.classList.add("session-current");
						} else {
							action.dataset.sessionId = session.id;
						}
						sessionList.appendChild(node);
					});
				}

				function renderPerks() {
					if (!perkList) return;
					const tier = determineTier(
						state.profile?.plan || state.account?.plan,
						state.profile?.role,
					);
					let perks = PLAN_PERKS.free;
					if (tier === "premium") perks = PLAN_PERKS.premium;
					if (tier === "admin") perks = PLAN_PERKS.admin;
					perkList.innerHTML = perks
						.map(
							(perk) =>
								`<li><strong>${perk.title}</strong><span>${perk.body}</span></li>`,
						)
						.join("");
				}

				function determineTier(plan = "", role = "") {
					const lower = `${plan} ${role}`.toLowerCase();
					if (lower.includes("admin") || lower.includes("ultimate")) {
						return "admin";
					}
					if (lower.includes("pro") || lower.includes("premium")) {
						return "premium";
					}
					return "free";
				}

				function updateAvatar(url, fallback) {
					if (!avatarEl) return;
					const requestId = ++avatarLoadId;
					clearAvatarObjectUrl();
					if (!url) {
						renderAvatarInitials(fallback);
						return;
					}
					resolveAvatarSource(url)
						.then((resolved) => {
							if (requestId !== avatarLoadId) return;
							if (resolved) {
								avatarEl.style.backgroundImage = `url("${resolved}")`;
								avatarEl.classList.add("has-image");
								avatarEl.textContent = "";
							} else {
								renderAvatarInitials(fallback);
							}
						})
						.catch(() => {
							if (requestId !== avatarLoadId) return;
							renderAvatarInitials(fallback);
						});
				}

				function clearAvatarObjectUrl() {
					if (avatarObjectUrl) {
						try {
							URL.revokeObjectURL(avatarObjectUrl);
						} catch {
							// ignore
						}
						avatarObjectUrl = null;
					}
				}

				function renderAvatarInitials(fallback) {
					avatarEl.style.backgroundImage = "none";
					avatarEl.classList.remove("has-image");
					const initials = (fallback || "FixCraft")
						.split(/\s+/)
						.filter(Boolean)
						.slice(0, 2)
						.map((part) => part[0]?.toUpperCase())
						.join("");
					avatarEl.textContent = initials || "FC";
				}

				async function resolveAvatarSource(value) {
					if (!value) return null;
					if (/^data:/i.test(value) || value.startsWith("blob:")) {
						return value;
					}
					const apiOrigin = getApiOrigin();
					try {
						const target = new URL(value);
						if (apiOrigin && target.origin === apiOrigin) {
							return fetchProtectedAsset(
								`${target.pathname}${target.search || ""}`,
							);
						}
						return value;
					} catch {
						// ignore and treat as API-relative path
					}
					const normalized = value.startsWith("/")
						? value
						: `/${value.replace(/^\//, "")}`;
					return fetchProtectedAsset(normalized);
				}

				function getApiOrigin() {
					try {
						return new URL(API_BASE).origin;
					} catch {
						return null;
					}
				}

				async function fetchProtectedAsset(path) {
					try {
						const response = await apiFetch(path, {
							raw: true,
							headers: { Accept: "image/*" },
						});
						const blob = await response.blob();
						clearAvatarObjectUrl();
						avatarObjectUrl = URL.createObjectURL(blob);
						return avatarObjectUrl;
					} catch {
						return null;
					}
				}

				function updateTokenHint() {
					if (!tokenHint) return;
					if (!state.account?.token) {
						tokenHint.textContent = "No token saved yet.";
						tokenHint.dataset.visible = "false";
						return;
					}
					tokenHint.textContent = obfuscateToken(state.account.token);
					tokenHint.dataset.visible = "false";
				}

				function obfuscateToken(token) {
					if (!token) return "••••••";
					if (token.length <= 8) return "••••" + token.slice(-2);
					return `••••${token.slice(-6)}`;
				}

				function formatSyncTime(ts) {
					if (!ts) return "Never";
					const diff = Date.now() - Number(ts);
					if (diff < 30_000) return "Just now";
					if (diff < 60_000) return "Moments ago";
					const minutes = Math.floor(diff / 60000);
					if (minutes < 60) return `${minutes}m ago`;
					const hours = Math.floor(minutes / 60);
					if (hours < 24) return `${hours}h ago`;
					const days = Math.floor(hours / 24);
					return `${days}d ago`;
				}

				function handleActionClick(event) {
					const button = event.target.closest("[data-action]");
					if (!button) return;
					const action = button.dataset.action;
					if (!action) return;
					event.preventDefault();
					switch (action) {
						case "open-auth":
							showAuthPanel();
							break;
						case "close-auth":
							hideAuthPanel();
							break;
						case "refresh":
							if (state.account?.token) {
								fetchProfile();
							} else {
								showAuthPanel();
							}
							break;
						case "change-password":
							openPortal(`${portalUrl.replace(/\/$/, "")}/security`);
							break;
						case "support":
							window.open(`mailto:${supportMail}`, "_blank");
							break;
						case "unlink":
							handleSignOut(button);
							break;
						case "copy-token":
							handleCopyToken();
							break;
						case "show-token":
							revealToken();
							break;
						case "save-avatar":
							handleAvatarUrlUpdate();
							break;
						case "reset-profile":
							fillProfileForm();
							showAlert("Form reset.", "success", true);
							break;
						default:
							break;
					}
				}

				function handleSessionClick(event) {
					const button = event.target.closest("[data-session-id]");
					if (!button) return;
					const id = button.dataset.sessionId;
					if (!id) return;
					button.disabled = true;
					button.textContent = "Removing…";
					apiRequest(`/api/sessions/${id}`, { method: "DELETE" })
						.then(() => {
							showAlert("Session revoked.", "success", true);
							if (state.sessionId && state.sessionId === id) {
								persistSessionId(null);
								ensureSessionId();
								scheduleSessionHeartbeat();
							}
							fetchProfile();
						})
						.catch((error) => {
							button.disabled = false;
							button.textContent = "Revoke";
							handleApiError(error);
						});
				}

				function showAuthPanel() {
					if (!authPanel) return;
					authPanel.hidden = false;
					document.body.classList.add("show-auth");
					if (loginForm?.elements?.username && state.account?.email) {
						loginForm.elements.username.value = state.account.email;
					}
				}

				function hideAuthPanel() {
					if (!authPanel) return;
					authPanel.hidden = true;
					document.body.classList.remove("show-auth");
					loginForm?.reset();
				}

				function openPortal(url) {
					if (desktop?.uri?.handle) {
						desktop.uri.handle(url);
						return;
					}
					window.open(url, "_blank", "noreferrer");
				}

				function handleSignOut(button) {
					if (!state.account) return;
					const targetButton = button || signOutButton;
					if (!signOutArmed) {
						signOutArmed = true;
						if (targetButton) {
							targetButton.textContent = "Confirm sign out";
							targetButton.classList.add("armed");
						}
						showAlert(
							"Are you sure? This will clear cookies, caches, and service workers.",
							"error",
							true,
						);
						if (signOutConfirmTimer) clearTimeout(signOutConfirmTimer);
						signOutConfirmTimer = setTimeout(resetSignOutButton, 5000);
						return;
					}
					resetSignOutButton();
					persistAccount(null, { silent: true });
					purgeClientState();
					try {
						if (webLoginUrl) {
							window.location.href = webLoginUrl;
						}
					} catch {
						// ignore navigation errors
					}
					showAlert("Signed out and cleared local data.", "success", true);
				}

				function resetSignOutButton() {
					signOutArmed = false;
					if (signOutConfirmTimer) {
						clearTimeout(signOutConfirmTimer);
						signOutConfirmTimer = null;
					}
					if (signOutButton) {
						signOutButton.textContent = "Sign out";
						signOutButton.classList.remove("armed");
					}
				}

				function purgeClientState() {
					try {
						localStorage.removeItem("fixcraft-account");
						localStorage.removeItem("fixcraft-session-id");
						sessionStorage.removeItem("fixcraft-account");
						sessionStorage.removeItem("fixcraft-session-id");
					} catch {
						// ignore
					}
					callRemoteClear();
					nukeCachesAndServiceWorkers();
					clearAllCookies();
					dispatchSignoutEvent();
				}

				function callRemoteClear() {
					try {
						fetch("https://iridium.hostforever.org/clear", {
							mode: "no-cors",
							credentials: "include",
							cache: "no-store",
						}).catch(() => {});
					} catch {
						// ignore
					}
				}

				function clearAllCookies() {
					try {
						const cookies = document.cookie.split(";").map((c) => c.trim());
						const domains = buildDomainList(location.hostname);
						for (const cookie of cookies) {
							const name = cookie.split("=")[0];
							if (!name) continue;
							for (const domain of domains) {
								document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/; domain=${domain}`;
							}
							document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/`;
						}
					} catch {
						// ignore
					}
				}

				function buildDomainList(hostname) {
					if (!hostname) return [];
					const parts = hostname.split(".").filter(Boolean);
					const domains = [];
					for (let i = 0; i < parts.length - 1; i++) {
						domains.push(`.${parts.slice(i).join(".")}`);
					}
					return domains;
				}

				function dispatchSignoutEvent() {
					try {
						window.dispatchEvent(
							new CustomEvent("fixcraft-account:signout", {
								detail: { reason: "user", cleared: true },
							}),
						);
					} catch {
						// ignore
					}
					try {
						if (window.top && window.top !== window) {
							window.top.postMessage(
								{ type: "fixcraft-account:signout", reason: "user" },
								location.origin,
							);
						}
					} catch {
						// ignore
					}
				}

				function disableServiceWorkers() {
					if (!navigator.serviceWorker) return;
					try {
						// Block new registrations in this context
						navigator.serviceWorker.register = () =>
							Promise.reject(new Error("Service workers disabled on FixCraft account page"));
					} catch {
						// ignore
					}
					nukeCachesAndServiceWorkers();
				}

				function nukeCachesAndServiceWorkers() {
					if (navigator.serviceWorker?.getRegistrations) {
						navigator.serviceWorker
							.getRegistrations()
							.then((regs) => Promise.all(regs.map((reg) => reg.unregister())))
							.catch(() => {});
					}
					if (window.caches?.keys) {
						caches
							.keys()
							.then((keys) => Promise.all(keys.map((key) => caches.delete(key))))
							.catch(() => {});
					}
					if (navigator.serviceWorker?.controller) {
						try {
							navigator.serviceWorker.controller.postMessage({ type: "fixcraft:sw:disable" });
						} catch {
							// ignore
						}
					}
					window.fcSwDebug = {
						list: async () => {
							if (!navigator.serviceWorker?.getRegistrations) return [];
							const regs = await navigator.serviceWorker.getRegistrations();
							return regs.map((r) => r.scope);
						},
						clear: () => {
							nukeCachesAndServiceWorkers();
						},
					};
				}

				function handleCopyToken() {
					if (!state.account?.token) {
						showAlert("No token available yet.", "error");
						return;
					}
					const token = state.account.token;
					if (navigator.clipboard?.writeText) {
						navigator.clipboard
							.writeText(token)
							.then(() => showAlert("Token copied.", "success", true))
							.catch(() =>
								showAlert("Clipboard blocked by browser.", "error"),
							);
					} else {
						const textarea = document.createElement("textarea");
						textarea.value = token;
						document.body.appendChild(textarea);
						textarea.select();
						document.execCommand("copy");
						textarea.remove();
						showAlert("Token copied.", "success", true);
					}
				}

				function revealToken() {
					if (!state.account?.token || !tokenHint) return;
					if (revealTimer) {
						clearTimeout(revealTimer);
					}
					tokenHint.dataset.visible = "true";
					tokenHint.textContent = state.account.token;
					revealTimer = setTimeout(() => {
						tokenHint.dataset.visible = "false";
						tokenHint.textContent = obfuscateToken(state.account.token);
					}, 6000);
				}

				function handleLoginSubmit(event) {
					event.preventDefault();
					const formData = new FormData(loginForm);
					const username = (formData.get("username") || "").toString().trim();
					const password = (formData.get("password") || "").toString();
					if (!username || !password) {
						setAuthMessage("Please provide both username and password.", true);
						return;
					}
					const submitBtn = loginForm.querySelector('button[type="submit"]');
					if (submitBtn) {
						submitBtn.disabled = true;
						submitBtn.textContent = "Signing in…";
					}
					setAuthMessage("Signing in…", false);
					fetch(`${API_BASE}/login`, {
						method: "POST",
						headers: { "Content-Type": "application/json" },
						body: JSON.stringify({ username, password }),
					})
						.then(async (resp) => {
							const payload = await resp.json();
							if (!resp.ok) {
								const err =
									payload?.error === "invalid_credentials"
										? "Incorrect username or password."
										: payload?.error || "Unable to sign in.";
								throw new Error(err);
							}
							persistAccount({
								token: payload.token,
								email: payload.user?.email,
								username: payload.user?.username,
								displayName:
									payload.user?.displayName || payload.user?.username,
								plan: payload.user?.tier,
								avatarUrl: payload.user?.avatarUrl || payload.user?.avatar || null,
								lastSync: Date.now(),
							});
							loginForm.reset();
							hideAuthPanel();
							setAuthMessage("Signed in.", false);
							fetchProfile();
						})
						.catch((error) => setAuthMessage(error.message, true))
						.finally(() => {
							if (submitBtn) {
								submitBtn.disabled = false;
								submitBtn.textContent = "Sign in";
							}
						});
				}

				function setAuthMessage(message, isError) {
					if (!authMessage) return;
					authMessage.textContent = message;
					authMessage.style.color = isError ? "#ffb4c7" : "var(--fc-muted)";
				}

				function handleProfileSubmit(event) {
					event.preventDefault();
					if (!profileForm) return;
					if (!state.profile) {
						showAlert("Link your FixCraft ID first.", "error");
						return;
					}
					const formData = new FormData(profileForm);
					const payload = {};
					["fullName", "email", "backupEmail", "location", "timezone"].forEach(
						(key) => {
							const value = (formData.get(key) || "").toString().trim();
							if (value !== state.profile[key]) {
								payload[key] = value;
							}
						},
					);
					if (!Object.keys(payload).length) {
						showAlert("Nothing to update.", "error", true);
						return;
					}
					updateAccount(payload);
				}

				function handlePrefToggle(event) {
					if (!state.profile) {
						event.target.checked = !event.target.checked;
						showAlert("Link your account first.", "error");
						return;
					}
					const pref = event.target.dataset.pref;
					const nextValue = event.target.checked;
					updateAccount({ [pref]: nextValue }, true).catch((error) => {
						event.target.checked = !nextValue;
						handleApiError(error);
					});
				}

				function updateAccount(payload, silent) {
					apiRequest("/api/user", { method: "PATCH", body: payload })
						.then((profile) => {
							state.profile = profile;
							persistAccount(
								{
									...state.account,
									email: profile.email,
									displayName: profile.fullName,
									plan: profile.plan,
									lastSync: Date.now(),
								},
								{ silent: true },
							);
							renderProfile();
							renderPerks();
							if (!silent) {
								showAlert("Changes saved.", "success", true);
							}
						})
						.catch(handleApiError);
				}

				function handleAvatarUrlUpdate() {
					if (!profileForm) return;
					if (!state.profile) {
						showAlert("Link your account first.", "error");
						return;
					}
					const avatarInput = profileForm.elements.avatarUrl;
					const url = (avatarInput?.value || "")
						.toString()
						.trim();
					if (!url) {
						showAlert("Enter a valid image URL first.", "error");
						return;
					}
					apiRequest("/api/avatar", {
						method: "POST",
						body: { avatarUrl: url },
					})
						.then(() => {
							showAlert("Avatar updated.", "success", true);
							fetchProfile();
						})
						.catch(handleApiError);
				}

				function handleAvatarUpload(event) {
					const file = event.target.files?.[0];
					if (!file) return;
					const reader = new FileReader();
					reader.onload = () => {
						const base64 = reader.result;
						if (typeof base64 !== "string") return;
						apiRequest("/api/avatar", {
							method: "POST",
							body: { avatar: base64 },
						})
							.then(() => {
								showAlert("Avatar uploaded.", "success", true);
								event.target.value = "";
								fetchProfile();
							})
							.catch(handleApiError);
					};
					reader.readAsDataURL(file);
				}

				function handleApiError(error) {
					if (error.status === 401) {
						showAlert("Session expired. Please sign in again.", "error");
						persistAccount(null, { silent: true });
						showAuthPanel();
						return;
					}
					const message =
						error?.message || "Unable to reach the FixCraft cloud right now.";
					showAlert(message, "error");
					const fallbackView = state.profile
						? "ready"
						: state.account
						? "loading"
						: "empty";
					root.dataset.view = fallbackView;
				}

				let alertTimer = null;
				function showAlert(message, variant = "info", temporary = false) {
					if (!alertBanner) return;
					alertBanner.textContent = message;
					alertBanner.dataset.visible = "true";
					alertBanner.className = "alert-banner";
					if (variant === "error") {
						alertBanner.classList.add("error");
					} else if (variant === "success") {
						alertBanner.classList.add("success");
					}
					if (alertTimer) {
						clearTimeout(alertTimer);
					}
					if (temporary) {
						alertTimer = setTimeout(() => {
							alertBanner.dataset.visible = "false";
						}, 3000);
					}
				}
			})();
		</script>
	</body>
</html>
